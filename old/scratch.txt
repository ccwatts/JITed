// // this occurs after a type check... unless?
// std::string resolve(std::string var_name, std::vector<std::shared_ptr<Statement>> stmts, std::map<std::string, std::vector<std::string>> fns, std::string rt) {
//     // fns
//     // idx 0 is return type, will be empty if void
//     // idx 1 through whatever, if present, will be arg types
//     bool is_struct;
//     std::string found_type = "";
//     for (auto it = stmts.begin(); it != stmts.end(); ++it) {
//         if ((*it)->uses(var_name)) {
//             std::string stmt_type = (*it)->typestr();
//             if (stmt_type == "alloc") {
//                 auto alloc_s = std::static_pointer_cast<AllocStatement>(*it);
//                 try_assign_type(found_type, alloc_s->target_type());
//             } else if (stmt_type == "binary") {
//                 // i8 or i32?
//                 // i8s only used for pointers -- probably because 64bit
//                 // both operands and result need to be ints in mini

//                 // i1 might be used at some point during binary operations
//                 // technically, there'll need to be promotions even if it's a boolean for more ops...?
//                 // auto binop_s = std::static_pointer_cast<BinaryStatement>(*it);
//                 // if (binop_s->is_boolean()) {
//                 //     return "i1";
//                 // } else {
//                 //     return "i32";
//                 // }
//                 // return "i32"; // used for both bool and ints, i guess.
//                 try_assign_type(found_type, "i32");
//             } else if (stmt_type == "branch") {
//                 // only one operand in a branch
//                 // return PTR_STR_T;
//                 try_assign_type(found_type, PTR_STR_T);
//             } else if (stmt_type == "cast") {
//                 // this MIGHT be unnecessary, depending on what the casts were actually used for
//                 // since type resolution is just a thing, could we look for spots to insert them automatically?
//                 // yeah, prolly
//                 auto cast_s = std::static_pointer_cast<CastStatement>(*it);
//                 if (cast_s->target_name() == var_name) {
//                     try_assign_type(found_type, cast_s->casted_type());
//                     // return cast_s->casted_type();
//                 }
//             } else if (stmt_type == "call") {
//                 auto call_s = std::static_pointer_cast<CallStatement>(*it);
//                 if (call_s->target_name() == var_name) {
//                     // look for fn return type
//                     try_assign_type(found_type, fns.at(call_s->func_name()).at(0));
//                 } else {
//                     int idx = call_s->idx_of(var_name);
//                     if (idx >= 0) {
//                         try_assign_type(found_type, fns.at(call_s->func_name()).at(idx));
//                     }
//                 }
//                 // should be an error if this happens
//             } else if (stmt_type == "load") {
//                 if ((*it)->target_name() == var_name) {
//                     continue; // ?
//                 } else {
//                     try_assign_type(found_type, PTR_STR_T);
//                 }
//             } else if (stmt_type == "store") {
//                 // intentionally blank, here for completeness of types (or not)
//                 continue; // this makes me feel kinda gross
//             } else if (stmt_type == "return") {
//                 try_assign_type(found_type, rt);
//             }
//         }
//     }
//     return found_type;
// }

// int builtins(std::map<std::string, std::set<std::string>>& bindings, Statement& stmt) {
//     auto intersect = [](std::set<std::string> a, std::set<std::string> b) {
//         std::set<std::string> intersection;
//         std::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::inserter(intersection, intersection.begin()));
//         return intersection;
//     };

//     std::string type = stmt.typestr();
//     if (type == "alloca") {

//     }

//     return 0; // no error
// }
